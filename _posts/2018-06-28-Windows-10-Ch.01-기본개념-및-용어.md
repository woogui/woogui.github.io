---
layout: post
title: Windows 10 기본 개념 및 용어
---

##Win API
**Win32 API(Windows Application Programming Interface)**
* 윈도우 64bit 버전이 발표되기 전에 윈도우 오리지널 16bit 버전에 대한 프로그래밍 인터페이스인 오리지널 16bit 윈도우 API와 구별하기 위해 윈도우 32bit 버전에 대한 프로그래밍 인터페이스를 Win32 API라고 했다
* 윈도우 API란 용어는 dnlsehdndml 32bit, 64bit 프로그래밍 인터페이스 양쪽 모두를 가리킨다.

**COM(Component Object Model)**
* C 유형의 함수로만 이뤄진 최초 윈도우 API의 단점인 함수명의 일관성 결여, 논리적 그룹화의 부족성, 연관된 함수의 수적인 측면을 해결하고자 만들어졌다.
* 최초 마이크로소프트 오피스 애플리케이션에서 문서 간의 데이터 통신과 교환(Object Linking and Embedding : OLE)을 위해 고안 되었으며, OLE는 동적 데이터 교환(DDE)로 불리는 예전의 윈도우 메시지 교환 메커니즘을 사용해 최초 구현되었다.
* COM 아래와 같은 두가지 기본적인 원리에 기반을 둔다.
	* 클라이언트는 인터페이스를 통해 객체와 통신한다.
	* 컴포넌트 구현 부분이 클라이언트에 정적으로 링크되는 것이 아니라 동적으로 로드된다.

**윈도우 런타임(WinRT)**
* 윈도우 8에서 새로운 윈도우 API와 윈도우 런타임으로 불리는 지원 런타임을 도입했다.
* 윈도우 앱 용도의 앱 개발자를 특별히 대상으로 하는 플랫폼 서비스로 이뤄져 있다.
* API관점에서 WinRT는 기본 COM 인프라에 다양한 확장을 추가해 COM 상단에 구축되어있다.

**.NET 프레임 워크 **
* .NET 프레임 워크는 윈도우의 일부분으로 아래와 같은 두개의 주요 컴포넌트로 이뤄져 있다.
	* 공통 언어 런타임(Common Language Runtime : CLR) : .NET을 위한 런타임 엔진으로 공통 중간언어 명령을 하부의 하드웨어 CPU머신 언어와 가비지 컬렉터, 유형검사, 코드 접근 보안 등의 명령으로 변환하는 JIT 컴파일러를 포함한다. CLR은 COM 인터페이스 서버로 구현돼 있으며, 윈도우 API가 제공하는 다양한 기능을 사용한다.
	* .NET 프레임워크 클래스 라이브러리 : 사용자 인터페이스 서비스와 네트워킹, 데이터베이스 접근 등과 같은 클라이언트와 서버 애플리케이션이 전형적으로 필요로 하는 기능을 구현하는 대규모 라이브러리다.
* 새로운 고급 프로그래밍 언어(C#, 비주얼 베이직, F#)와 지원 툴을 포함한 기능을 제공함으로써 개발자 생산성을 개선, 대상 애플리케이션의 안전성과 신뢰성을 향상 시킨다.

![](https://i.imgur.com/ALlwtSe.jpg ".NET과 윈도우 OS 간의 관계")


##서비스와 함수, 루틴
**윈도우 API 함수** : 윈도우 API에 문서화돼 있고 호출 가능한 서브루틴

**네이티브 시스템 서비스(또는 시스템 호출)** : 운영체제 하부에 있는 문서화되지 않은 서비스로, 유저 모드에서 호출 가능하다.

**커널 지원 함수(또는 루틴)** : 커널 모드에서만 호출 가능한 윈도우 운영체제 내부의 서브루틴

**윈도우 서비스** : 윈도우 서비스 컨트롤 관리자에 의해 시작된 프로세스

**DLL(동적 연결 라이브러리)** : 호출 가능한 서브루틴들이 모여 있는 바이너리 파일로, 이 서브루틴을 사용하는 애플리케이션에 의해 동적으로 로드될 수 있다.
* 정적 라이브러리 대비 DLL의 장점은 애플리케이션 간에 DLL을 공유할 수 있다는 것과, 윈도우는 애플리케이션이 참조하고 있는 DLL의 코드가 메모리상에 하나의 복사본만 존재하게 한다는 것이다.

##프로세스
프로그램과 프로세스는 표면상으로 유사하지만 본질적으로 서로 다르다. 프로그램은 명령의 정적 연속체인 반면, 프로세스는 프로그램의 인스턴스가 실행될 때 사용되는 리소스의 집합을 위한 컨테이너이다.
추상적이고 고차원적 관점에서 볼 때 윈도우 프로세스는 다음와 같이 구성되어 있다.
* 전용 가상 주소 공간 : 프로세스가 사용할 수 있는 가상 메모리 주소의 집합
* 실행 가능한 프로그램 : 초기 코드와 데이터를 정의하고 프로세스의 가상 주소 공간에 맵핑됭다.
* 오픈 핸들 목록 : 프로세스 내의 모든 스레드에서 접근 가능한 세마포어와 동기화 객체, 파일 같은 다양한 시스템 리소스에 대응된다.
* 보안 컨텍스트 : 해당 앱컨테이너 식별자와 이에 관련된 샌드박스 정보와 더불어 프로세스와 연관된 사용자와 보안 그룹, 특권, 속성, 클레임, 기능, 사용자 계정 컨트롤, 가상화 상태, 제한된 사용자 계정 상태를 식별한다.
* 프로세스 ID : 고유한 식별자로서 내부적으로는 클라이언트 ID라고 하는 식별자의 일부
* 최소 하나의 실행 스레드 : 윈도우 프로세스는 최소 하나의 실행 스레드를 갖는다. 빈 프로세스도 가능하지만 거의 쓸모가 없다.

##스레드
스레드는 실행을 위해 윈도우가 스케줄링 하는 프로세스 내의 개체로 스레드 없이는 프로세스의 프로그램이 실행될 수 없다.
스레드는 다음과 같은 필수적인 구성요소를 포함한다.
* 프로세서의 상태를 표현하는 CPU 레지스터 집합의 내용
* 두 개의 스택 : 스레드가 커널모드와 유저모드에서 각각 실행될 때 사용하기 위한 것
* 스레드 로컬 스토리지(Thread-Local Storage : TLS) : 서브시스템과 런타임 라이브러리, DLL이 사용하기 위한 전용 저장 영역
* 스레드 ID : 고유한 식별자로 내부적으로는 클라이언트 ID라고 하고 프로세스 ID와는 같은 네임스페이스에 생성되기 때문에 겹치지 않는다.

한 스레드에서 다른 스레드로의 실행 전환은 커널 스케줄러가 관여하기 때문에 값비싼 동작이다. 따라서 윈도우는 이 비용을 절감하기 위해 다음과 같은 두가지 메커니즘을 사용한다.
* 파이버(fiber) : 애플리케이션이 윈도우에 내장된 우선순위 기반 스케줄링 메커니즘에 의존하는 대신에 자신의 실행 '스레드'를 스케줄링하는 것을 허용한다. 따라서 경량 스레드로 불리기도 하며, 유저 모드인 Kernel32.dll에 구현돼 있기 때문에 스케줄링 관점에서 파이버는 커널에서 보이지 않는다.
	* 파이버는 커널에 보이지 않기 때문에 다수의 파이버가 한 스레드에서 실행될 경우 TLS공유와 같은 문제점이 생기기 때문에 적절한방법이 아니다.
	* 파이버는 하나 이상의 프로세서에서 동시에 실행될 수 없으며, 협력적 멀티태스킹에만 한정적으로 사용가능하다.
* 유저 모드 스케줄링 스레드(UMS 스레드) : 파이버가 가진 기본적인 장점을 제공하며, 자신의 커널 스레드 상태를 갖고 있어서 커널에 보인다.

##잡
윈도우는 잡이라고 하는 프로세스 모델에 대한 확장을 제공한다.
잡 객체는 다음과 같은 기능을 제공한다.
* 프로세스 그룹을 하나의 단위로 관리하고 조작하게 한다.
* 특정 속성을 제어하고 잡과 연관된 특정 프로세스에 제약을 가할 수 있다.
* 잡에 연관된 모든 프로세스와 잡에 에 연관돼 있지만, 이미 종료된 모든 프로세스에 대한 기본 게정 정보를 기록한다.
* 몇 가지 방법으로 윈도우에 프로세스 트리 구조가 없는 것에 대한 보완재 역할을 한다.

##가상 메모리
윈도우는 각 프로세스가 자신만의 고유한 큰 주소 공간을 갖도록 하기위해 선형 주소 공간에 기반을 둔 가상 메모리 시스템을 구현했다.
가상 메모리는 물리적인 배치에 대해 고려하지 않아도 되는 메모리의 논리적인 뷰를 제공한다.

![](https://i.imgur.com/vHCenCp.jpg "페이징을 이용한 가상 메모리에서 물리 메모리로의 맵핑")
위 그림은 가상 메모리 일부는 물리 메모리에 맵핑되어 있고, 나머지 부분은 디스크에 페이징되어 있는 가상메모리를 이용하는 두 프로세스를 보여준다.
가상 주소 공간의 크기는 각 하드웨어 플랫폼에 따라 다르다.

아래는 32비트 윈도우에 의해 지원되는 두개의 전형적인 가상주소 공간 배치와 64비트 시스템 주소 공간의 배치를 나타낸다.
![](https://i.imgur.com/IHnLk7S.jpg "32비트 윈도우의 전형적인 주소 공간 배치")
![](https://i.imgur.com/QwnwrYs.jpg "64비트 윈도우의 주소 공간 배치")

##커널모드와 유저모드
유저 애플리케이션이 운영체제의 치명적인 데이터에 접근하거나 수정하는 것을 막기 위해 윈도우는 두 가지 프로세서 접근 모드를 사용하며 이에 따라 유저 애플리케이션 코드는 유저모드에서 실행되고 운영체제 코드는 커널모드에서 실행된다.
커널 모드는 모든 시스템 메모리와 모든 CPU 명령어에 접근이 허가된 프로세서 실행모드를 말한다.
* 일부 프로세서는 코드 특권 레벨이나 링 레벨 같은 용어를 사용해 모드를 구분하며, 일부 프로세서는 슈퍼바이저 모드와 애플리케이현 모드 같은 용어로 이를 구분한다.

유저 애플리케이션은 시스템 서비스를 호출할 때 유저 모드에서 커널 모드로 전환 된다. 따라서 일반적인 경우 유저 스레드는 실행 시간중 일부는 유저 모드에서 소비하고 일부는 커널 모드에서 소비한다.

##하이퍼바이저
하이퍼바이저는 가상 메모리에서 물리 메모리로의 장치 인터럽트, PCI와 USB 장치에 이르기 까지 머신의 모든 자원을 가상화하고 격리시켜 주는 특화되고 매우 특권이 높은 구성요소를 말한다.
윈도우 10에서 제공하는 하이퍼바이저 하이퍼-V를 이용해 마이크로소프트는 다음과 같은 가상화 기반의 보안(Virtualization-Based Security : VBS) 서비스를 제공한다.
* 장치가드 : 하이퍼바이저 코드 무결성을 제공한다. 이를 통해 유저 모드와 커널 모드 코드 모두에 대해 KMCS 단독일 때보다 강력한 코드 서명 보장을 하며, 윈도우 OS의 서명 정책을 맞춤화 할 수 있다.
* 하이펴 가드 : 핵심적인 커널 관련 구조체와 하이퍼바이저 관련 구조체, 코드를 보호한다.
* 자격증명 가드 : 보안 생체 인식 기술로서 도메인 계정 자격즡명에 대한 비인가된 접근으로부터 보호를 한다.
* 애플리케이션 가드 : 마이크로소프트 에지 브라우저에 좀다 강력한 샌드박스를 제공한다.
* 호스트 가디언과 차단막(Shielded Fabric) 가상 TPM을 이용해 자신이 실행하는 인프라로부터 가상머신을 보호한다.

이 외에도 하어퍼-V 하이퍼바이저는 악이적 이용과 그 밖의 보안 공격에 대해 일부 핵심적인 커널 부분을 보완해준다.

##펌웨어
펌웨어는 윈도우 8이후의 시스템에서 문제가 없는 부트 과정을 보장하는 신뢰성 연결고리의 기본을 제공하는 역할을 한다.
윈도우가 명시한 UEFI표준의 일부에 따르면 부트 관련 소프트웨어의 서명 요건에 대한 강력한 보장과 요구 사항을 가진 안전한 부트 구현이 반드시 존재해야 하고, 윈도우 구성요소는 이런 검증 과정을 통해 부트 과정의 첫 시작부터 안전하게 로드된다는 것을 보장받는다. 그리고 신뢰 플랫폼 모듈과 같은 기술은 신뢰성을 제공하기 위한 과정을 측정할 수 있는데 마이크로소프트는 업계와의 동반 관계를 통해 부트 소프트웨어 오류나 손상에 대비한 UEFI 신뢰 부트 구성 요소에 대한 화이트리스트와 블랙리스트를 관리한다.
위의 과정을 시스템 펌웨어의 범주에서 관리한다.

##터미널 서비스와 다중 세션
윈도우 터미널 서비스를 통해 원격 사용자는 다른 머신에 세션을 열고 로그인해 서버에 애플리케이션을 실행할 수 있다. 서버는 GUI를 클라이언트로 전달하고 클라이언트는 사용자의 입력을 서버러 다시 보내는 방식으로 사용된다.
* 윈도우 클라이언트 버전에는 단일 원격 유저만 머신에 접속할 수 있게 허용한다.
* 윈도우 서버 시스템은 동시에 두 개의 원격 접속을 지원한다.
* 윈도우 클라이언트 버전은 한번에 하나씩 사용 가능한 빠른 사용자 전환 이라는 기능을 통해 로컬에서 생성된 다중 세션을 지원한다.

##객체와 핸들
**커널 객체** : 객체 유형에 의해 정적으로 정의된 단일, 런타임 인스탄스
**객체 유형** : 시스템이 정의한 데이터 유형과 그 인스턴스가 작용하는 함수들, 객체 속성 집합으로 구성된다.
**객체 속성** : 객체의 상태를 부분적으로 정의하는 객체 내의 데이터 필드
**객체 메소드** : 객체 속성을 읽거나 변경하는 등 객체를 조작하는 것
**객체 관리자** : 시스템 작업을 수행하는 데 편리한 방법을 제공하는 커널 컴포넌트로 다음과 같은 작업을 수행한다.
* 시스템 리소스에 대해 사람이 읽을 수 있는 이름을 제공
* 프로세스 간 리소스와 데이터 공유
* 비인가된 접근으로부터 리소스 보호
* 언제 객체가 더 이상 사용되지 않는지를 시스템이 알 수 있게 해서 객체가 자동으로 할당 해제될 수 있게 하는 추적 참조

**핸들** : 객체 인스턴스에 대한 참조 역할

##보안
윈도우의 핵심 보안 특성은 다음을 포함한다.
* 파일과 디렉터리, 프로세스, 스레드 등과 같은 모든 공유 가능한 시스템 객체에 대한 임시적이고도 필수적인 무결성 보호
* 어떤 실체나 유저, 이들이 이르킨 행위에 대한 보안 검사
* 로그온 시 사용자 인증
* 다른 사용자가 해제한 자원을 초기화 하지 않고 접근하는 것에 대한 보호

윈도우의 객체에 대한 접근 제어는 세가지 형태가 있다.
* 임의 접근 제어 : 대다수의 사람들이 운영체제 보안에 대해 생각할 때 생각하는 보호 매커니즘. 객체의 소유자가 다른 이들에게 접근을 허가하거나 거부하는 방법.
* 특권 접근 제어 : 임의 접근 제어가 충분하지 않을 경우 필요. 소유자가 존재하지 않으면 누군가가 보호된 객체를 얻을 수 있다는 것을 확실하게 보장하는 한 방법.
* 강제 무결성 제어 : 동일한 유저 계정 안에서 접근되는 객체를 보호하기 위해 보안 제어의 추가적 레벨이 요구될 때 필요한 제어

##레지스트리
레지스트리는 부트와 시스템 설정, 윈도우의 동작을 제어하는 시스템 전역적인 소프트웨어 설정, 보안 데이터베이스, 스크린 세이버 사용같은 사용자별 설정을 담고 있는 시스템 데이터베이스이다.
레지스트리는 윈도우 성능 카운터와 마찬가지로 시스템의 현재 하드웨어 상태와 같은 메모리에 있는 휘발성 데이터를 들여달 볼 수 있다.
대부분의 레지스트리 키는 시스템 전역적 구성 하이브인 HKEY_LOCAL_MACHINE 하위에 존재하며 약어는 HKLM이다.

##유니코드
윈도우는 대부분의 내부 문자열을 16비트 와이드 유니코드 문자로 저장하고 처리한다.
많은 애플리케이션이 8비트 ANSI 문자열을 다루기 때문에 문자열 인자를 받아들이는 많은 윈도우 함수는 유니코드, ANSI 버전 두 개의 진입점을 가진다.